[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15541894&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is the application of principles, methods, and tools in engineering. These are all applied to create and develop quality solutions that help solve a problem. The software engineering process includes the design, development, testing, deployment, and maintenance stages. Software development is an important part of the tech field, as well as all other fields/sectors in the world. The applications created are used in all sectors, going from healthcare and education to military and politics. We use various applications every day and they play an important role in making them work and work more efficiently.

Identify and describe at least three key milestones in the evolution of software engineering.
One of the milestones in the evolution of software engineering was when software engineering was established as a discipline in the 1960s. It was first introduced in 1968 at the NATO Software Engineering Conference in Germany. At the event, the importance and need for software development to apply engineering practices was emphasized to ensure quality and good, efficient work. The need came to be recognized as the projects became more complex and since there were no clear principles in place, this led to what they called the 'software crisis'. The 'software crisis' was a time when many complex projects often went over the planned budget, were of low quality, or were completed late. A second milestone was the advent of structured programming in the 1970s. Developers sought to bring more structure into coding to make the approach more logical and clear for developers. Part of this meant breaking down the programming into smaller, more manageable sets of code and also making the coding less complex. An example of how they did this was introducing what they called the 'Three Basic Structures' - sequence, selection, and iteration. This helped reduce the number of lines needed in their code and easier to understand. Now, the third milestone I will tell you about is the rise of Agile methodologies in the 2000s. This sparked the start of a major shift in how software development teams worked on projects. The Agile methodology is a project management approach that is a more flexible approach that has its own set of principles focused around 4 core values. This allows for teams to make appropriate adjustments and revise the plan when necessary, to deliver the best possible product while still maintaining the broader sense of the plan.

List and briefly explain the phases of the Software Development Life Cycle.
There are 6 phases in the Software Development Life Cycle, with a 7th one which is 'optional'. As with any cycle, there is a certain order in which they are done to maintain order and ensure the necessary steps are taken before proceeding to the next. The following are the different phases in order: 1.) Requirement: This phase entails gathering and analyzing information to determine the requirements for the software. These requirements are written in Software Requirements Specification (SRS) documents and feasibility studies are also conducted with the results of the studies being added to a feasibility report. 2.) System design: During this phase, we take the requirements from the previous phase to guide us toward creating a detailed design and architecture of the software. This means clearly outlining how the software should flow, data flow, algorithms, and interfaces, among other aspects of the software. This will serve as a point of reference for the teams involved in the project for the entire project duration. It's an important phase that could impact the outcome of the next phases and aspects such as budgeting throughout the project. The documents involved here are the design documents including the Detailed Design (DD) and the High-level Design (HLD), as well as the architectural diagrams. 3.) Implementation: This phase is all about the programming of the software. A common practice during this phase is unit testing which tends to be done by each developer to ensure each piece of code functions properly. 4.) Testing: As the name suggests, the testing phase is where numerous tests are conducted to determine if there are any bugs that need to be addressed and whether the software meets the intended needs and requirements and design determined in the initial two phases. Various types of tests are conducted including security testing, acceptance testing, and performance testing. 5.) Deployment: During the deployment phase, the software is released for end-users to use. The deployment includes deploying the software to production servers; configuring and setting up tasks; initial training and documentation for users; and rollout strategies which will be chosen based on the needs of the project. 6.) Maintenance: This is a continuous phase that starts once the software has been deployed to end-users, and involves fixing bugs, making updates and patches, and constantly monitoring the performance of the software. 7.) Retirement (optional): Retirement is the final phase and is an optional one. It is, as the name suggests when the software is deemed as no longer needed or it is replaced with a new system. This phase involves a decommissioning plan, transition documentation, and archived data.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
At first glance, one distinct difference between the Waterfall and Agile methodologies is the level of flexibility each methodology allows. While the Agile methodology is known for its flexibility, the Waterfall methodology is, in comparison, not as flexible. The Waterfall methodology follows a specific sequence of phases, and the Agile methodology is an iterative approach that is based on changes which means it may repeat certain phases again if deemed necessary. Both of these methodologies have their pros and cons. We will look at two examples where each methodology would be better than the other. The Agile methodology is better when: the projects are unclear or the requirements keep evolving; the projects are complex and have a high-risk level; projects that need constant feedback from the stakeholders or customers; the projects' are time sensitive; and projects with cross-functional teams that are also small in numbers. An example where this methodology would be better is a project where you need to develop a custom app solution for a client who wants to be closely and actively involved, to ensure the final product comes out exactly as they expect it to in order to meet their needs. The Waterfall methodology is better when the projects: are well defined and the requirements are stable; have strict compliance and/or regulatory requirements; consist of various teams and the project is a large-scale one; have fixed-scope contracts and fixed prices; and require a high level of documentation. An example where this methodology would be better is when building software for a bank as they have set strict regulations.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
A software developer is responsible for taking the software design plans and implementing the programming part of the project to ensure it fits the design plan. A quality assurance engineer ensures the software is functioning and functioning as it is supposed to, and they do this by designing test plans and executing them. This involves various tests to ensure the quality is up to the expected standard. A project manager takes care of the planning for the project, and the execution of the entire project, and ensures that the product is delivered, preferably on time, within budget, and according to the requirements.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
There are a number of reasons why both IDEs and VCSs are important in the software development process. We'll start by looking at the reason why IDEs are important. IDEs improve efficiency and productivity as they have integrated tools that check for errors in our code, help us complete code, and highlight different syntax in different colours to make it more readable. The next reason is for the debugging support we get where we are showing which line the error occurred in, oftentimes it states the reason for the error, and it is able to check all of the lines of code for us each time. These are some of the reasons, however, to sum it up, Integrated Development Environments (IDEs) increase the productivity, efficiency, and quality of the code. Next, we have the Version Control Systems (VCSs) which is important for a number of reasons including for collaboration amongst team members, keeping a record of who made what changes to ensure accountability and avoid conflict, and identifying which changes may have introduced a bug and revert back to the version without a bug.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Some of the common challenges experienced in software engineering are: 1.) Changing requirements in a project which can lead to delays, changed/new requirements, increased costs, resource strain, and an extended project scope. 2.) Tight deadlines which can lead to the project team/s rushing to complete the project in time, only to deliver a product of low quality. 3.) Technical debt is often a result of a rushed product that has many issues that need to be fixed, which results in the team having to work further and in a more complex way to fix the code and product. There are a few strategies we can use to avoid these challenges or at least minimize their impact. These strategies include using agile methodologies, regularly reassessing the project goals and timelines, using effective communication, and prioritizing tasks.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
The four types of testing are an essential part of quality assurance to ensure the products meet the quality standards and the functional requirements of the project. It makes sure the code is reviewed to check for any bugs, automatically tests the code, and continuously integrates. This is to identify any issues earlier in the development to stay on top of any issues, avoid unnecessary challenges down the line, and ensure high-quality products. Unit testing is when developers test individual modules of the software to check for any bugs or defects. Integration testing is the testing of interactions between the different subsystems or components in the software. System testing is when the whole software is tested. And lastly, acceptance testing is when we test the software against the user requirements to make sure it meets the user needs stipulated during the first two phases of the Software Development Life Cycle.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is all about posing statements or questions with AI models in a way that will provide the best response. AI models need good prompts in order to provide you with the best possible responses. This means that if you provide bad prompts which include broad, vague, or unclear prompts, the AI model is less likely to provide you with the best response. However, if you provide good prompts that are clear and provide as much detail as possible, the AI model will be able to provide a good response. This is why it is important to understand the best practices to make a good prompt so that you can make the best possible use of AI models such as the ChatGPT chatbot.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Vague prompt example: Tell me about the world's history. 
Improved prompt: Tell me about the history of South Africa during the 1850s, and list all of the major events in descending order. If there are any major events that took place within different tribes, be clear about that and mention them. Include all of the events and let me know if there is anything else I can ask you to make sure I cover all of the major events during those years. 
The improved prompt is more effective because I was more specific about the information I was looking for including the years. I also mentioned different tribes to make sure the AI model considered all of them and didn't just focus on what was more popular or prominent. Another aspect mentioned in the prompt about mentioning if there is anything else it deems necessary for me to know in order to have a better understanding, it should let me know.
